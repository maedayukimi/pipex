今回使う関数

open	close	read	write	malloc	free	perror	strerror	access	dup	dup2
execve	exit	fork	pipe	unlink	wait	waitpid

************************************************************************************************************************

int	open(const char *pathname, int flags, mode_t mode);

************************************************************************************************************************

int	fd;
fd = open("file.txt", O_RDONLY); のように使う。
flagの種類は
O_RDONLY O_WRONLY O_RDWR O_CREAT O_TRUNC O_APPENDの6種類のflagが存在する
左から順に読み込み専用、書き込み専用、読み書き可能、存在しない場合は作成(modeを打ち込む必要あり)、
既存ファイルを空にする、末尾に追加書き込み である
使い方としては上の通りで、ファイルのパスを引き渡しそのファイルのfdを取得する。

************************************************************************************************************************

int	close(int fd);

************************************************************************************************************************

close(fd); のように使う。
closeを行うことで使用したfdを閉じてリソースを解放できる。それを忘れるとfd leakになり、エラーが発生する

************************************************************************************************************************

ssize_t	read(int fd, void *buf, size_t count);

************************************************************************************************************************

char	buffer[42];
ssize_t	bites_read;

bites_read = read(fd, buffer, 42); のように使う。
fdから100bite読み取り、bufferに格納する。戻り値として返ってくるのは
bites_read > 0 -> 読み取ったbite数
bites_read == 0 -> ファイルの終端(EOF)
bites_read == -1 -> エラー、errnoにエラーコードがセットされる...という感じ
readを使うことで用意したchar bufferにfdから指定したbiteの分だけ読み取り、入力することができる。

************************************************************************************************************************

ssize_t	write(int fd, const void buf[.count], size_t count);

************************************************************************************************************************

write(fd, "Hello, World!", 13);のように使う。
stdinのfdに出力する内容のbufferポインタを引き渡すか、直接配列を引き渡し、countのbite分だけ書き込む。
writeもssize_tをreturnするのだが、こちらも大体の場合はエラー管理用に使われる。
そのためエラー時は-1がreturnされるようになっている。

************************************************************************************************************************

void	*malloc(size_t size);

************************************************************************************************************************

char	*buf;

buf = malloc(sizeof(char) * 42);
if (buf == NULL)
	perror("malloc failed");のように使う。
言わずもがなのよく使う関数。mallocとはmemory allocateの略で、メモリを動的に確保することができる。
これを使うことで配列で宣言せずともポインタで必要な分だけメモリを確保することができるが、
使用し終わった際にfreeを使ってメモリを解放する必要がある。

************************************************************************************************************************

void	free(void *ptr);

************************************************************************************************************************

char	*str;
str = malloc(sizeof(char) * 42);
strcpy(str, "Hello, World!");
printf("%s", str);
free(str);のように使う。

strに必要な分だけallocate、使用した後はfreeしても既にstrを扱うフェイズは終了しているので、
freeして不必要なbufferを解放する必要がある。これが抜けているとmemory leakが発生するため、超重要。

************************************************************************************************************************

void	perror(const char *s);

************************************************************************************************************************

fd = open("NULL.txt", O_RDONLY);
if (fd == -1)
{
	perror("open failed.\n");
	exit(EXIT_FAILURE);
}のように使う。

perrorを用いると、エラーメッセージを表示できる。しかし、exitなど終了を伴っている関数ではないので、
コード内にperrorとは別に終了するための関数を追加しておく必要がある。
printout errorの略か？

************************************************************************************************************************

char	*strerror(int errnum);

************************************************************************************************************************

printf("ERROR 2: %s\n", strerror(2));このように使う。

strerrorを用いると、引き渡されたerrnoに応じてエラーメッセージを表示する。
つまり、perrorと似たような関数。しかし違いとしては
perrorはstdoutでエラーメッセージを、strerrorはchar *でエラーメッセージを返す。
string errorの略だ。多分。

************************************************************************************************************************

int	access(const char *pathname, int mode);

************************************************************************************************************************

if (access("file.txt", R_OK) == 0)
	printf("file.txt is readable");のように使う。

modeとしてはR_OK, W_OK, X_OK, F_OK の4つがあり、左から順に
読み取り可能か、書き込み可能か、実行可能か、存在するかをチェックしている。つまり、権限を調べている。
pipexではX_OKを用いて打ち込まれたコマンドが実際に実行可能かでチェックできる。

************************************************************************************************************************

int	dup(int oldfd);

************************************************************************************************************************

int	fd1;
int	fd2;

fd1 = open("file.txt", O_WRONLY);
if (fd == -1)
{
	perror("open failed");
	exit(EXIT_FAILURE);
}
fd2 = dup(fd1);
write(fd2, "The cake is a Lie!\n", 18);
close(fd1);
close(fd2);のように使う。

oldfdをコピーし、newfdを作成する。dupは最も小さい未使用のfdを返す。
もちろんold newともにcloseしなければfd leakが発生するので注意。
例えば、今回のpipexにおいては下に記したdup2でstdoutを変更する可能性がある。
その前にstdoutを別にdupでコピーしておいて後に戻すっていうことをするかもしれない。

************************************************************************************************************************

int	dup2(int oldfd, int newfd);

************************************************************************************************************************

int	fd;

fd = open("file.txt", O_WRONLY);
if (fd == -1)
{
	perror("open failed");
	exit(EXIT_FAILURE);
}
dup2(fd, STDOUT_FILENO);
close(fd);
printf("This will be writen to file.txt");のように使う。

今回のpipexではdup2を用いてstdin stdoutの接続をすることになる。
例えば上の例でいうと
file.txtのfdを取得、そしてエラー処理。その後、dup2を実行して、
STDOUT_FILENO(標準出力のfdパラメータ)をfdに変更する。つまり、"This will be~"の出力先がfdになる。
つまり、file.txtに記入される。この特性をしっかり使いこなす必要がある。

************************************************************************************************************************

int	execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);

************************************************************************************************************************

int	main()
{
	execve("/bin/ls", ft_split("/bin/ls", "-l"), "NULL);
	printf("The cake is a Lie!\n");
	return (1);
}のように使う。

このコードではexecveを実行した後printfしreturn (1) する関数になっている。
しかし、コンパイルされたa.out実行ファイルを実行するとls -l を実行し、execveから下は実行されないようになっている。
execveが成功すると、元のa.outとしての機能は実質消え、指定されたPATHをもとに実行ファイルを探し、見つかった場合
その実行ファイルを実行する形になる。そして、プロセス自体が消えてしまうのでバッファリングされているものなども
無視されてしまうようになってしまう。

************************************************************************************************************************

void	exit(int status);

************************************************************************************************************************

exitはプログラムを終了させるお馴染みの関数。

今回の課題ではfolkして子プロセスに分けたそれをexitで終了させる流れになるはず。
異常終了したときはexit(EXIT_FAILURE); で。

************************************************************************************************************************

pid_t	fork(void);

************************************************************************************************************************

int	main()
{
	pid_t	pid;

	pid = fork();
	if (pid == -1)
	{
		perror("fork failed");
		return (1);
	}
	if (pid == 0)
		printf("the cake is a lie!");
	else
	{
		wait(NULL);
		printf("THE CAKE IS A LIE!");
	}
	return (0);
}のように使う。

forkを使うことでpid_tを取得することができる。pidとはProcess IDの略であり、実行するプロセスの番号である。
pid == 0の場合、それは子プロセスを表しており、そこでプロセスを分割し、並行してプロセスを実行することができる。
また、execveを使用するということは上記の通りそれから下のコードを読み取らないということなので、
forkで分割した子プロセスにexecveを使用させるのが今回のポイント。
またexample内のfork_test上でforkした後でprintfとexecveを同時に行ったケースのように
execveが成功した際にバッファリングを用いる関数は前後関係なく管理を手放すため、実行されないことに注意。
forkを使うとpid_tが取得できるが、あくまで子プロセス上ではpid = 0なので、親プロセス上でpidが保持されている。
そのため、親プロセス上でwaitpidをpidとともに用いることで特定のプロセスの終了を待つことができる。

************************************************************************************************************************

int	pipe(int pipefd[2]);

************************************************************************************************************************

int	main()
{
	int	fd[2];
	char	buffer[42];

	pipe(fd);
	write(fd[1], "Hello, Pipe!", 13);
	read(fd[0], buffer, 13);
	printf("Received: %s\n", buffer);
	return (0);
}...=>Received: Hello, Pipe!のように使われる。

上からわかるように宣言した配列型のfdをpipeで繋げることができる。
fd[0], fd[1]はそれぞれread writeの関係なので、入力専用、書き込み専用で分ける必要がある。
本来、プロセスが違うもの同士だとデータの共有が困難であるが、
pipeを用いてfdをそれぞれで運用することで、forkした後もデータを繋げることが可能になる。
forkする際のpipeの使い方は以下のような感じ。

int main(void)
{
	int	fd[2];
	pid_t	pid;
	char	buffer[42];
	char	msg[42];
	ssize_t	count;

	strcpy(msg, "Hello from child!");
	if (pipe(fd) == -1)
	{
		perror("pipe failed");
		exit(EXIT_FAILURE);
	}
	pid = fork();
	if (pid < 0)
	{
		perror("fork failed");
		exit(EXIT_FAILURE);
	}
	else if (pid == 0)
	{
		close(fd[0]);
		write(fd[1], msg, strlen(msg));
		close(fd[1]);
		exit(EXIT_SUCCESS);
	}
	else
	{
		close(fd[1]);
		count = read(fd[0], buffer, sizeof(buffer) - 1);
		if (count > 0)
		{
			buffer[count] = '\0';
			printf("Parent received: %s\n", buffer);
		}
		close(fd[0]);
		exit(EXIT_SUCCESS);
	}
	return (0);
}


************************************************************************************************************************

int	unlink(const char *pathname);

************************************************************************************************************************

int main(void)
{
	if (unlink("testfile.txt") == -1)
	{
		perror("unlink");
		return (1);
	}
	printf("File 'testfile.txt' has been unlinked successfully.\n");
	return (0);
}のように使う。

unlinkを用いることで、

************************************************************************************************************************

pid_t	wait(int *_Nullable wstatus);

************************************************************************************************************************

	if (pid == 0)
		printf("the cake is a lie!");
	else
	{
		wait(NULL);
		printf("THE CAKE IS A LIE!");
	}のように使う。
waitを用いることで、子プロセスが終了したのを確認してから親プロセスの実行に移る。
本来これは並行して実行されているので、waitがないと子プロセスの実行と親プロセスのそれのどちらが先に出力されるかが
ランダムになってしまう、それを防ぐための関数。

************************************************************************************************************************

pid_t	waitpid(pid_t pid, int *_Nullable wstatus, int options);

************************************************************************************************************************

	pid1 = fork();
	if (pid1 == 0)
	{
		sleep(2);
		printf("Child 1 exiting\n");
		exit(1);
	}
	pid2 = fork();
	if (pid2 == 0)
	{
		sleep(1);
		printf("Child 2 exiting\n");
		exit(2);
	}

	waitpid(pid2, &status, 0);
	printf("Child 2 exiting with status %d\n", WEXITSTATUS(status));

	waitpid(pid1, &status, 0);
	printf("Child 1 exiting with status %d\n", WEXITSTATUS(status));

	return (0);
}のように使う。

forkで取得したpidをもとに、そのプロセスが終了するのを待つというwaitの強化版みたいなもの。
waitはいずれかのpidの終了とともに親プロセスを再開するが、waitpidは特定のpidの終了に対応する。
WEXITSTATUSとはexitの戻り値を取得するマクロ。
